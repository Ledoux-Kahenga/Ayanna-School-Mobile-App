import 'package:ayanna_school/models/entities/classe.dart';
import 'package:ayanna_school/models/entities/eleve.dart';
import 'package:ayanna_school/models/entities/enseignant.dart';
import 'package:ayanna_school/models/entities/frais_scolaire.dart';
import 'package:ayanna_school/models/entities/frais_classes.dart';
import 'package:ayanna_school/models/entities/note_periode.dart';
import 'package:ayanna_school/models/entities/paiement_frais.dart';
import 'package:ayanna_school/models/entities/utilisateur.dart';
import 'package:ayanna_school/models/entities/entreprise.dart';
import 'package:ayanna_school/models/entities/responsable.dart';
import 'package:ayanna_school/models/entities/classe_comptable.dart';
import 'package:ayanna_school/models/entities/compte_comptable.dart';
import 'package:ayanna_school/models/entities/licence.dart';
import 'package:ayanna_school/models/entities/annee_scolaire.dart';
import 'package:ayanna_school/models/entities/periode.dart';
import 'package:ayanna_school/models/entities/config_ecole.dart';
import 'package:ayanna_school/models/entities/comptes_config.dart';
import 'package:ayanna_school/models/entities/periodes_classes.dart';
import 'package:ayanna_school/models/entities/cours.dart';
import 'package:ayanna_school/models/entities/creance.dart';
import 'package:ayanna_school/models/entities/journal_comptable.dart';
import 'package:ayanna_school/models/entities/depense.dart';
import 'package:ayanna_school/models/entities/ecriture_comptable.dart';
import 'package:connectivity_plus/connectivity_plus.dart';

import 'package:ayanna_school/services/providers/data_provider.dart';
import 'package:ayanna_school/services/providers/shared_preferences_provider.dart';
import 'package:ayanna_school/services/providers/database_provider.dart';
import 'api_client_provider.dart';
import 'package:ayanna_school/services/helpers/sync_upload_helper.dart';
import 'package:ayanna_school/services/helpers/id_mapping_helper.dart';
import 'package:ayanna_school/models/sync_upload_request.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../api/sync_service.dart';
import '../../models/sync_response.dart';

part 'sync_provider_new.g.dart';

/// √âtats de synchronisation
enum SyncStatus { idle, downloading, uploading, processing, error }

class SyncState {
  final SyncStatus status;
  final String? message;
  final DateTime? lastSync;
  final int? totalChanges;
  final int? processedChanges;
  final String? error;

  const SyncState({
    this.status = SyncStatus.idle,
    this.message,
    this.lastSync,
    this.totalChanges,
    this.processedChanges,
    this.error,
  });

  SyncState copyWith({
    SyncStatus? status,
    String? message,
    DateTime? lastSync,
    int? totalChanges,
    int? processedChanges,
    String? error,
  }) {
    return SyncState(
      status: status ?? this.status,
      message: message ?? this.message,
      lastSync: lastSync ?? this.lastSync,
      totalChanges: totalChanges ?? this.totalChanges,
      processedChanges: processedChanges ?? this.processedChanges,
      error: error ?? this.error,
    );
  }

  double get progress {
    if (totalChanges == null || processedChanges == null || totalChanges == 0) {
      return 0.0;
    }
    return processedChanges! / totalChanges!;
  }
}

/// Gestionnaire de synchronisation
class SyncManager {
  final SyncService _syncService;

  SyncManager(this._syncService);

  /// Synchronise les donn√©es depuis le serveur
  Future<SyncResponse?> downloadChanges({
    required String userEmail,
    DateTime? since,
  }) async {
    print(
      'üì• [SYNC-MANAGER] D√©marrage t√©l√©chargement changements pour $userEmail',
    );
    try {
      final sinceString =
          since?.toIso8601String() ?? '1970-01-01T00:00:00.000Z';
      print('üìÖ [SYNC-MANAGER] Depuis: $sinceString');

      final response = await _syncService.downloadChanges(
        since: sinceString,
        clientId: 'flutter-client',
        userEmail: userEmail,
      );

      return response.body;
    } catch (e) {
      print('‚ùå [SYNC-MANAGER] Erreur t√©l√©chargement: $e');
      rethrow;
    }
  }

  /// Upload les changements locaux avec la nouvelle structure
  Future<SyncUploadResponse?> uploadChanges(
    SyncUploadRequest uploadRequest,
  ) async {
    print('üì§ [SYNC-MANAGER] D√©marrage upload changements');
    try {
      print(
        'üìä [SYNC-MANAGER] Nombre de changements: ${uploadRequest.changes.length}',
      );

      final response = await _syncService.uploadChanges(uploadRequest);

      if (response.isSuccessful && response.body != null) {
        // response.body est d√©j√† de type SyncUploadResponse
        final uploadResponse = response.body!;
        print('‚úÖ [SYNC-MANAGER] Upload r√©ussi: ${uploadResponse.message}');
        if (uploadResponse.idMapping != null &&
            uploadResponse.idMapping!.isNotEmpty) {
          print(
            'üîÑ [SYNC-MANAGER] Mapping IDs d√©tect√©: ${uploadResponse.idMapping!.length} mappings',
          );
        }
        return uploadResponse;
      }
      print('‚ùå [SYNC-MANAGER] Upload √©chou√©: ${response.statusCode}');
      return null;
    } catch (e) {
      print('‚ùå [SYNC-MANAGER] Erreur upload: $e ${StackTrace.current}');
      rethrow;
    }
  }

  /// Upload les changements locaux (version legacy)
  Future<SyncUploadResponse?> uploadChangesLegacy(
    Map<String, dynamic> changes,
  ) async {
    print('üì§ [SYNC-MANAGER] D√©marrage upload legacy');
    try {
      // Convertir le Map en SyncUploadRequest pour compatibilit√©
      final builder = SyncUploadRequestBuilder(
        clientId: changes['client_id'] ?? 'flutter-client',
      );

      final changesList = changes['changes'] as List<dynamic>? ?? [];
      print(
        'üìä [SYNC-MANAGER] Conversion ${changesList.length} changements legacy',
      );

      for (final change in changesList) {
        final changeMap = change as Map<String, dynamic>;
        builder.addChange(
          SyncChangeUpload(
            table: changeMap['table'],
            operation: changeMap['operation'],
            action: changeMap['action'],
            data: changeMap['data'],
          ),
        );
      }

      final uploadRequest = builder.build();
      final response = await _syncService.uploadChanges(uploadRequest);

      if (response.isSuccessful && response.body != null) {
        print('‚úÖ [SYNC-MANAGER] Upload legacy r√©ussi');
        return response.body;
      }
      print('‚ùå [SYNC-MANAGER] Upload legacy √©chou√©');
      return null;
    } catch (e) {
      print('‚ùå [SYNC-MANAGER] Erreur upload legacy: $e');
      rethrow;
    }
  }

  /// Marque les changements comme synchronis√©s
  Future<bool> acknowledgeChanges(List<String> changeIds) async {
    print('‚úÖ [SYNC-MANAGER] Acquittement ${changeIds.length} changements');
    try {
      final response = await _syncService.acknowledgeChanges({
        'change_ids': changeIds,
      });

      final success = response.isSuccessful;
      print('üìã [SYNC-MANAGER] Acquittement ${success ? 'r√©ussi' : '√©chou√©'}');
      return success;
    } catch (e) {
      print('‚ùå [SYNC-MANAGER] Erreur acquittement: $e');
      return false;
    }
  }

  /// V√©rifie la connectivit√© avec le serveur
  Future<bool> ping() async {
    print('üèì [SYNC-MANAGER] Ping du serveur');
    try {
      final response = await _syncService.ping();
      final success = response.isSuccessful;
      print('üèì [SYNC-MANAGER] Ping ${success ? 'r√©ussi' : '√©chou√©'}');
      return success;
    } catch (e) {
      print('‚ùå [SYNC-MANAGER] Erreur ping: $e');
      return false;
    }
  }

  /// Obtient le statut de synchronisation
  Future<Map<String, dynamic>?> getSyncStatus(String userEmail) async {
    print('üìä [SYNC-MANAGER] R√©cup√©ration statut sync pour $userEmail');
    try {
      final response = await _syncService.getSyncStatus(userEmail: userEmail);

      if (response.isSuccessful && response.body != null) {
        print('‚úÖ [SYNC-MANAGER] Statut sync r√©cup√©r√©');
        return response.body;
      }
      print('‚ùå [SYNC-MANAGER] √âchec r√©cup√©ration statut sync');
      return null;
    } catch (e) {
      print('‚ùå [SYNC-MANAGER] Erreur statut sync: $e');
      return null;
    }
  }
}

/// Provider pour le service de synchronisation
@riverpod
SyncService syncService(SyncServiceRef ref) {
  return ref.watch(apiClientProvider).syncService;
}

/// Provider pour g√©rer la synchronisation bidirectionnelle
@riverpod
SyncManager syncManager(SyncManagerRef ref) {
  final syncService = ref.watch(syncServiceProvider);
  return SyncManager(syncService);
}

/// Provider pour l'√©tat de synchronisation
@riverpod
class SyncStateNotifier extends _$SyncStateNotifier {
  late final SyncManager _syncManager;

  @override
  SyncState build() {
    _syncManager = ref.watch(syncManagerProvider);
    return const SyncState();
  }

  /// Upload une seule entit√© (pour les op√©rations CRUD individuelles)
  Future<void> uploadSingleEntity<T>(
    T entity,
    String tableName,
    String operation, { // 'create', 'update', 'delete'
    required String userEmail,
  }) async {
    print(
      'üì§ [SYNC] Upload entit√© individuelle: $tableName, op√©ration: $operation, utilisateur: $userEmail',
    );
    final helper = SyncUploadHelper(clientId: 'flutter-client');

    try {
      // Ajouter l'entit√© selon l'op√©ration
      switch (operation.toLowerCase()) {
        case 'create':
          print('‚ûï [SYNC] Ajout cr√©ation entit√© $tableName');
          helper.addEntity(
            entity,
            tableName,
            SyncOperation.insert,
            toJson: (e) => (e as dynamic).toJson(),
            getServerId: (e) => (e as dynamic).serverId,
          );
          break;
        case 'update':
          print('üîÑ [SYNC] Ajout mise √† jour entit√© $tableName');
          helper.addEntity(
            entity,
            tableName,
            SyncOperation.update,
            toJson: (e) => (e as dynamic).toJson(),
            getServerId: (e) => (e as dynamic).serverId,
          );
          break;
        case 'delete':
          print('üóëÔ∏è [SYNC] Ajout suppression entit√© $tableName');
          helper.addEntity(
            entity,
            tableName,
            SyncOperation.delete,
            toJson: (e) => (e as dynamic).toJson(),
            getServerId: (e) => (e as dynamic).serverId,
          );
          break;
        default:
          print('‚ùå [SYNC] Op√©ration non support√©e: $operation');
          throw ArgumentError('Op√©ration non support√©e: $operation');
      }

      if (helper.hasChanges) {
        print('üì§ [SYNC] Envoi de l\'entit√© au serveur');
        final uploadRequest = helper.build();
        final response = await _syncManager.uploadChanges(uploadRequest);

        if (response != null && response.success) {
          print('‚úÖ [SYNC] Upload r√©ussi');
          // Traitement du mapping des IDs si n√©cessaire
          if (response.hasIdMapping) {
            print('üîÑ [SYNC] Traitement mapping IDs');
            final idMappingHelper = IdMappingHelper(ref);
            await idMappingHelper.processIdMapping(response);
          }

          // Marquer l'entit√© comme synchronis√©e
          print('‚úÖ [SYNC] Marquage entit√© comme synchronis√©e');
          await _markSingleEntityAsSynced(entity, tableName);
        } else {
          print('‚ùå [SYNC] √âchec upload entit√©');
        }
      } else {
        print('‚ö†Ô∏è [SYNC] Aucune modification √† uploader');
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur upload entit√© $tableName: $e');
      rethrow;
    }
  }

  /// Marquer une entit√© individuelle comme synchronis√©e
  Future<void> _markSingleEntityAsSynced<T>(T entity, String tableName) async {
    print('‚úÖ [SYNC] Marquage entit√© individuelle synchronis√©e: $tableName');
    final database = ref.read(databaseProvider);

    try {
      // Mettre √† jour isSync = true pour l'entit√©
      final entityWithSync = entity as dynamic;
      entityWithSync.isSync = true;

      switch (tableName) {
        case 'eleves':
          print('üë®‚Äçüéì [SYNC] Marquage √©l√®ve synchronis√©');
          await database.eleveDao.updateEleve(entityWithSync as Eleve);
          break;
        case 'enseignants':
          print('üë®‚Äçüè´ [SYNC] Marquage enseignant synchronis√©');
          await database.enseignantDao.updateEnseignant(
            entityWithSync as Enseignant,
          );
          break;
        case 'classes':
          print('üè´ [SYNC] Marquage classe synchronis√©e');
          await database.classeDao.updateClasse(entityWithSync as Classe);
          break;
        // Ajouter d'autres cas selon les besoins
        default:
          print(
            '‚ö†Ô∏è [SYNC] Table non support√©e pour le marquage sync: $tableName',
          );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur marquage synchronisation pour $tableName: $e');
    }
  }

  /// Lance une synchronisation compl√®te
  Future<void> performFullSync(String userEmail) async {
    print('üîÑ [SYNC] D√©marrage synchronisation compl√®te pour $userEmail');
    try {
      state = state.copyWith(
        status: SyncStatus.downloading,
        message: 'T√©l√©chargement des changements...',
        error: null,
      );
      print('üì• [SYNC] √âtat chang√©: downloading');

      // R√©cup√©rer la derni√®re date de synchronisation depuis SharedPreferences
      final syncPrefs = ref.read(syncPreferencesNotifierProvider.notifier);
      final lastSyncDate = await syncPrefs.getLastSyncDate();
      print('üìÖ [SYNC] Derni√®re sync: $lastSyncDate');

      // T√©l√©charger les changements depuis la derni√®re synchronisation
      final syncResponse = await _syncManager.downloadChanges(
        userEmail: userEmail,
        since: lastSyncDate,
      );

      if (syncResponse == null) {
        print('‚ùå [SYNC] R√©ponse de t√©l√©chargement nulle');
        state = state.copyWith(
          status: SyncStatus.error,
          error: '√âchec du t√©l√©chargement des changements',
        );
        return;
      }

      print('üìä [SYNC] ${syncResponse.total} changements √† traiter');
      state = state.copyWith(
        status: SyncStatus.processing,
        message: 'Traitement des changements...',
        totalChanges: syncResponse.total,
        processedChanges: 0,
        lastSync: lastSyncDate,
      );

      // Traiter les changements
      await _processChanges(syncResponse.changes);

      // Sauvegarder la nouvelle date de synchronisation
      final now = DateTime.now();
      await syncPrefs.saveLastSyncDate(now);
      await syncPrefs.saveLastSyncUserEmail(userEmail);
      print('üíæ [SYNC] Dates sauvegard√©es: $now pour $userEmail');

      state = state.copyWith(
        status: SyncStatus.idle,
        message: 'Synchronisation termin√©e',
        lastSync: now,
        processedChanges: syncResponse.total,
      );
      print('‚úÖ [SYNC] Synchronisation compl√®te termin√©e');
    } catch (e) {
      print('‚ùå [SYNC] Erreur synchronisation compl√®te: $e');
      state = state.copyWith(
        status: SyncStatus.error,
        error: 'Erreur de synchronisation: $e',
      );
    }
  }

  /// Traite une liste de changements
  Future<void> _processChanges(List<SyncChange> changes) async {
    print('‚öôÔ∏è [SYNC] D√©marrage traitement ${changes.length} changements');
    int processed = 0;

    // Debug: Afficher la distribution des changements par table
    Map<String, int> tableCounts = {};
    for (final change in changes) {
      tableCounts[change.table] = (tableCounts[change.table] ?? 0) + 1;
    }
    print('üîç [SYNC] DEBUG - Distribution des changements: $tableCounts');

    List<Eleve> eleves = [];
    List<Classe> classes = [];
    List<Enseignant> enseignants = [];
    List<NotePeriode> notes = [];
    List<PaiementFrais> paiements = [];
    List<Utilisateur> utilisateurs = [];
    List<FraisScolaire> fraisScolaires = [];
    List<FraisClasses> fraisClasses = [];
    List<Entreprise> entreprises = [];
    List<Responsable> responsables = [];
    List<ClasseComptable> classesComptables = [];
    List<CompteComptable> comptesComptables = [];
    List<Licence> licences = [];
    List<AnneeScolaire> anneesScolaires = [];
    List<Periode> periodes = [];
    List<ConfigEcole> configsEcole = [];
    List<ComptesConfig> comptesConfigs = [];
    List<PeriodesClasses> periodesClasses = [];
    List<Cours> cours = [];
    List<Creance> creances = [];
    List<JournalComptable> journauxComptables = [];
    List<Depense> depenses = [];
    List<EcritureComptable> ecrituresComptables = [];

    for (final change in changes) {
      final table = change.table;
      switch (table) {
        case 'eleves':
          eleves.add(Eleve.fromJson(change.data));
          break;
        case 'classes':
          classes.add(Classe.fromJson(change.data));
          break;
        case 'enseignants':
          enseignants.add(Enseignant.fromJson(change.data));
          break;
        case 'notes_periode':
          notes.add(NotePeriode.fromJson(change.data));
          break;
        case 'paiement_frais':
          paiements.add(PaiementFrais.fromJson(change.data));
          break;
        case 'utilisateurs':
          utilisateurs.add(Utilisateur.fromJson(change.data));
          break;
        case 'frais_scolaires':
          fraisScolaires.add(FraisScolaire.fromJson(change.data));
          break;
        case 'frais_classes':
          fraisClasses.add(FraisClasses.fromJson(change.data));
          break;
        case 'entreprises':
          entreprises.add(Entreprise.fromJson(change.data));
          break;
        case 'responsables':
          responsables.add(Responsable.fromJson(change.data));
          break;
        case 'classes_comptables':
          classesComptables.add(ClasseComptable.fromJson(change.data));
          break;
        case 'comptes_comptables':
          comptesComptables.add(CompteComptable.fromJson(change.data));
          break;
        case 'licence':
          licences.add(Licence.fromJson(change.data));
          break;
        case 'annees_scolaires':
          anneesScolaires.add(AnneeScolaire.fromJson(change.data));
          break;
        case 'periodes':
          periodes.add(Periode.fromJson(change.data));
          break;
        case 'config_ecole':
          configsEcole.add(ConfigEcole.fromJson(change.data));
          break;
        case 'comptes_config':
          comptesConfigs.add(ComptesConfig.fromJson(change.data));
          break;
        case 'periodes_classes':
          periodesClasses.add(PeriodesClasses.fromJson(change.data));
          break;
        case 'cours':
          cours.add(Cours.fromJson(change.data));
          break;
        case 'creances':
          creances.add(Creance.fromJson(change.data));
          break;
        case 'journaux_comptables':
          journauxComptables.add(JournalComptable.fromJson(change.data));
          break;
        case 'depenses':
          depenses.add(Depense.fromJson(change.data));
          break;
        case 'ecritures_comptables':
          ecrituresComptables.add(EcritureComptable.fromJson(change.data));
          break;
        default:
          print('‚ö†Ô∏è [SYNC] Table non g√©r√©e: ${change.table}');
      }
      processed++;

      state = state.copyWith(
        processedChanges: processed,
        message: 'Traitement ${change.table}...',
      );
    }

    print('üíæ [SYNC] Enregistrement des changements en base locale');

    // Debug: Afficher le nombre d'entit√©s collect√©es par type
    print('üîç [SYNC] DEBUG - Entit√©s collect√©es:');
    print('  - entreprises: ${entreprises.length}');
    print('  - anneesScolaires: ${anneesScolaires.length}');
    print('  - utilisateurs: ${utilisateurs.length}');
    print('  - enseignants: ${enseignants.length}');
    print('  - responsables: ${responsables.length}');
    print('  - classes: ${classes.length}');
    print('  - eleves: ${eleves.length}');
    print('  - fraisScolaires: ${fraisScolaires.length}');
    print('  - fraisClasses: ${fraisClasses.length}');

    state = state.copyWith(
      status: SyncStatus.idle,
      message: 'Enregistrement des changements en cours...',
      processedChanges: processed,
    );

    // Appel des m√©thodes refresh pour toutes les entit√©s collect√©es
    // ORDRE IMPORTANT : Les entit√©s parentes doivent √™tre synchronis√©es avant les enfants

    // 1. Entit√©s de base (sans d√©pendances)
    print(
      'üîç [SYNC] DEBUG - Nombre d\'entreprises collect√©es: ${entreprises.length}',
    );
    if (entreprises.isNotEmpty) {
      print('üè¢ [SYNC] Refresh ${entreprises.length} entreprises');
      await ref.read(entreprisesNotifierProvider.notifier).refresh(entreprises);
    } else {
      print(
        '‚ö†Ô∏è [SYNC] Aucune entreprise √† synchroniser - v√©rification base locale...',
      );
      // V√©rifier si des entreprises existent d√©j√† en base
      final existingEntreprises = await ref.read(
        entreprisesNotifierProvider.future,
      );
      print(
        'üìä [SYNC] Entreprises existantes en base: ${existingEntreprises.length}',
      );
      if (existingEntreprises.isNotEmpty) {
        print(
          'üè¢ [SYNC] Entreprises en base: ${existingEntreprises.map((e) => '${e.id}:${e.nom}').join(', ')}',
        );
      }
    }

    if (anneesScolaires.isNotEmpty) {
      print('ÔøΩ [SYNC] Refresh ${anneesScolaires.length} ann√©es scolaires');
      await ref
          .read(anneesScolairesNotifierProvider.notifier)
          .refresh(anneesScolaires);
    }

    if (utilisateurs.isNotEmpty) {
      print('üë§ [SYNC] Refresh ${utilisateurs.length} utilisateurs');
      await ref
          .read(utilisateursNotifierProvider.notifier)
          .refresh(utilisateurs);
    }

    if (enseignants.isNotEmpty) {
      print('ÔøΩ‚Äçüè´ [SYNC] Refresh ${enseignants.length} enseignants');
      await ref.read(enseignantsNotifierProvider.notifier).refresh(enseignants);
    }

    if (responsables.isNotEmpty) {
      print('ÔøΩ‚Äçüë©‚Äçüëß‚Äçüë¶ [SYNC] Refresh ${responsables.length} responsables');
      await ref
          .read(responsablesNotifierProvider.notifier)
          .refresh(responsables);
    }

    // 2. Entit√©s d√©pendant des entit√©s de base
    if (classes.isNotEmpty) {
      print('üè´ [SYNC] Refresh ${classes.length} classes');
      await ref.read(classesNotifierProvider.notifier).refresh(classes);
    }

    if (eleves.isNotEmpty) {
      print('ÔøΩ‚Äçüéì [SYNC] Refresh ${eleves.length} √©l√®ves');
      await ref.read(elevesNotifierProvider.notifier).refresh(eleves);
    }

    if (fraisScolaires.isNotEmpty) {
      print('üìã [SYNC] Refresh ${fraisScolaires.length} frais scolaires');
      await ref
          .read(fraisScolairesNotifierProvider.notifier)
          .refresh(fraisScolaires);
    }

    if (fraisClasses.isNotEmpty) {
      print('ÔøΩ [SYNC] Refresh ${fraisClasses.length} frais classes');
      await ref
          .read(fraisClassesNotifierProvider.notifier)
          .refresh(fraisClasses);
    }

    // 3. Entit√©s comptables
    if (classesComptables.isNotEmpty) {
      print('üìä [SYNC] Refresh ${classesComptables.length} classes comptables');
      await ref
          .read(classesComptablesNotifierProvider.notifier)
          .refresh(classesComptables);
    }

    if (comptesComptables.isNotEmpty) {
      print('üíº [SYNC] Refresh ${comptesComptables.length} comptes comptables');
      await ref
          .read(comptesComptablesNotifierProvider.notifier)
          .refresh(comptesComptables);
    }

    // 4. Autres entit√©s
    if (licences.isNotEmpty) {
      print('üìú [SYNC] Refresh ${licences.length} licences');
      await ref.read(licencesNotifierProvider.notifier).refresh(licences);
    }

    if (periodes.isNotEmpty) {
      print('‚è∞ [SYNC] Refresh ${periodes.length} p√©riodes');
      await ref.read(periodesNotifierProvider.notifier).refresh(periodes);
    }

    if (configsEcole.isNotEmpty) {
      print('‚öôÔ∏è [SYNC] Refresh ${configsEcole.length} configs √©cole');
      await ref
          .read(configEcolesNotifierProvider.notifier)
          .refresh(configsEcole);
    }

    if (comptesConfigs.isNotEmpty) {
      print('üîß [SYNC] Refresh ${comptesConfigs.length} configs comptes');
      await ref
          .read(comptesConfigsNotifierProvider.notifier)
          .refresh(comptesConfigs);
    }

    if (periodesClasses.isNotEmpty) {
      print('üìö [SYNC] Refresh ${periodesClasses.length} p√©riodes-classes');
      await ref
          .read(periodesClassesNotifierProvider.notifier)
          .refresh(periodesClasses);
    }
    if (cours.isNotEmpty) {
      print('üìñ [SYNC] Refresh ${cours.length} cours');
      await ref.read(coursNotifierProvider.notifier).refresh(cours);
    }
    if (creances.isNotEmpty) {
      print('üí≥ [SYNC] Refresh ${creances.length} cr√©ances');
      await ref.read(creancesNotifierProvider.notifier).refresh(creances);
    }
    if (journauxComptables.isNotEmpty) {
      print(
        'üìì [SYNC] Refresh ${journauxComptables.length} journaux comptables',
      );
      await ref
          .read(journauxComptablesNotifierProvider.notifier)
          .refresh(journauxComptables);
    }
    if (depenses.isNotEmpty) {
      print('üí∏ [SYNC] Refresh ${depenses.length} d√©penses');
      await ref.read(depensesNotifierProvider.notifier).refresh(depenses);
    }
    if (ecrituresComptables.isNotEmpty) {
      print(
        'üìù [SYNC] Refresh ${ecrituresComptables.length} √©critures comptables',
      );
      await ref
          .read(ecrituresComptablesNotifierProvider.notifier)
          .refresh(ecrituresComptables);
    }

    // 5. Entit√©s restantes (notes, paiements, etc.)
    if (notes.isNotEmpty) {
      print('üìö [SYNC] Refresh ${notes.length} notes');
      await ref.read(notesPeriodesNotifierProvider.notifier).refresh(notes);
    }

    if (paiements.isNotEmpty) {
      print('üí∞ [SYNC] Refresh ${paiements.length} paiements');
      await ref
          .read(paiementsFraisNotifierProvider.notifier)
          .refresh(paiements);
    }

    state = state.copyWith(
      status: SyncStatus.idle,
      message: 'Tous les changements ont √©t√© enregistr√©s',
      processedChanges: processed,
    );
    print('‚úÖ [SYNC] Traitement des changements termin√©');
  }

  /// Traite un changement individuel

  /// V√©rifie la connectivit√©
  Future<bool> checkConnectivity() async {
    try {
      print('üåê [CONNECTIVITY] V√©rification directe de la connectivit√©...');
      final results = await Connectivity().checkConnectivity();
      final isConnected =
          results.contains(ConnectivityResult.wifi) ||
          results.contains(ConnectivityResult.mobile) ||
          results.contains(ConnectivityResult.ethernet);
      print(
        'üåê [CONNECTIVITY] R√©sultats directs: $results, isConnected: $isConnected',
      );
      return isConnected;
    } catch (e) {
      print(
        '‚ùå [CONNECTIVITY] Erreur lors de la v√©rification directe de connectivit√©: $e',
      );
      return false;
    }
  }

  /*   /// V√©rifie si une synchronisation est n√©cessaire
  Future<bool> isSyncNeeded({int muniteThreshold = 1}) async {
    print(
      '‚è∞ [SYNC] V√©rification si synchronisation n√©cessaire (seuil: ${muniteThreshold}h)',
    );
    final syncPrefs = ref.read(syncPreferencesNotifierProvider.notifier);
    final needed = await syncPrefs.isSyncNeeded(muniteThreshold: muniteThreshold);
    print(
      '‚è∞ [SYNC] Synchronisation ${needed ? 'n√©cessaire' : 'non n√©cessaire'}',
    );
    return needed;
  } */

  /// Obtient la derni√®re date de synchronisation
  Future<DateTime?> getLastSyncDate() async {
    print('üìÖ [SYNC] R√©cup√©ration derni√®re date de synchronisation');
    final syncPrefs = ref.read(syncPreferencesNotifierProvider.notifier);
    final date = await syncPrefs.getLastSyncDate();
    print('üìÖ [SYNC] Derni√®re date: $date');
    return date;
  }

  /// Obtient l'email du dernier utilisateur synchronis√©
  Future<String?> getLastSyncUserEmail() async {
    print('üë§ [SYNC] R√©cup√©ration dernier email utilisateur synchronis√©');
    final syncPrefs = ref.read(syncPreferencesNotifierProvider.notifier);
    final email = await syncPrefs.getLastSyncUserEmail();
    print('üë§ [SYNC] Dernier email: $email');
    return email;
  }

  /// Collecte et upload les changements locaux non synchronis√©s
  Future<void> uploadLocalChanges(String userEmail) async {
    print('üì§ [SYNC] D√©marrage upload changements locaux pour $userEmail');
    state = state.copyWith(
      status: SyncStatus.uploading,
      message: 'Collecte des changements locaux...',
    );

    try {
      final helper = SyncUploadHelper(clientId: 'flutter-client');
      print('üîç [SYNC] Collecte des changements non synchronis√©s');

      // Collecter tous les changements non synchronis√©s
      await _collectUnsyncedChanges(helper);

      if (!helper.hasChanges) {
        print('‚ÑπÔ∏è [SYNC] Aucun changement local √† synchroniser');
        state = state.copyWith(
          status: SyncStatus.idle,
          message: 'Aucun changement local √† synchroniser',
        );
        return;
      }

      print('üìä [SYNC] ${helper.changeCount} changements √† uploader');
      state = state.copyWith(
        message: 'Upload de ${helper.changeCount} changements...',
        totalChanges: helper.changeCount,
        processedChanges: 0,
      );

      // Construire et envoyer la requ√™te
      final uploadRequest = helper.build();
      final response = await _syncManager.uploadChanges(uploadRequest);

      if (response != null) {
        print('‚úÖ [SYNC] Upload r√©ussi: ${response.message}');
        // Traiter le mapping des IDs si pr√©sent
        if (response.hasIdMapping) {
          print('üîÑ [SYNC] Traitement du mapping des IDs');
          final idMappingHelper = IdMappingHelper(ref);
          await idMappingHelper.processIdMapping(response);

          final mappingSummary = idMappingHelper.getIdMappingSummary(response);
          print('üìã [SYNC] Mapping IDs: $mappingSummary');
          state = state.copyWith(
            status: SyncStatus.idle,
            message: 'Upload termin√© avec succ√®s. $mappingSummary',
            processedChanges: helper.changeCount,
          );
        } else {
          // Marquer les √©l√©ments comme synchronis√©s (ancienne m√©thode)
          print('‚úÖ [SYNC] Marquage des changements comme synchronis√©s');
          await _markChangesAsSynced(helper);

          state = state.copyWith(
            status: SyncStatus.idle,
            message: 'Upload termin√© avec succ√®s',
            processedChanges: helper.changeCount,
          );
        }
      } else {
        print('‚ùå [SYNC] √âchec de l\'upload: r√©ponse nulle');
        throw Exception('√âchec de l\'upload');
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur upload changements locaux: $e');
      state = state.copyWith(
        status: SyncStatus.error,
        error: 'Erreur upload: $e',
      );
      rethrow;
    }
  }

  /// Collecte tous les changements non synchronis√©s
  Future<void> _collectUnsyncedChanges(SyncUploadHelper helper) async {
    print('üîç [SYNC] D√©marrage collecte changements non synchronis√©s');
    final database = ref.read(databaseProvider);

    // Collecter les √©l√®ves non synchronis√©s
    try {
      final unsyncedEleves = await database.eleveDao.getUnsyncedEleves();
      print(
        'üë®‚Äçüéì [SYNC] ${unsyncedEleves.length} √©l√®ves non synchronis√©s trouv√©s',
      );
      for (final eleve in unsyncedEleves) {
        if (eleve.serverId != null) {
          helper.addEleve(eleve, operation: SyncOperation.update);
        } else {
          helper.addEleve(eleve, operation: SyncOperation.insert);
        }
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte √©l√®ves: $e');
    }

    // Collecter les enseignants non synchronis√©s
    try {
      final unsyncedEnseignants = await database.enseignantDao
          .getUnsyncedEnseignants();
      print(
        'üë®‚Äçüè´ [SYNC] ${unsyncedEnseignants.length} enseignants non synchronis√©s trouv√©s',
      );
      for (final enseignant in unsyncedEnseignants) {
        if (enseignant.serverId != null) {
          helper.addEnseignant(enseignant, operation: SyncOperation.update);
        } else {
          helper.addEnseignant(enseignant, operation: SyncOperation.insert);
        }
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte enseignants: $e');
    }

    // Collecter les classes non synchronis√©es
    try {
      final unsyncedClasses = await database.classeDao.getUnsyncedClasses();
      print(
        'üè´ [SYNC] ${unsyncedClasses.length} classes non synchronis√©es trouv√©es',
      );
      for (final classe in unsyncedClasses) {
        if (classe.serverId != null) {
          helper.addClasse(classe, operation: SyncOperation.update);
        } else {
          helper.addClasse(classe, operation: SyncOperation.insert);
        }
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte classes: $e');
    }

    // Collecter les ann√©es scolaires non synchronis√©es
    try {
      final unsyncedAnnees = await database.anneeScolaireDao
          .getUnsyncedAnneesScolaires();
      print(
        'üìÖ [SYNC] ${unsyncedAnnees.length} ann√©es scolaires non synchronis√©es trouv√©es',
      );
      for (final annee in unsyncedAnnees) {
        if (annee.serverId != null) {
          helper.addAnneeScolaire(annee, operation: SyncOperation.update);
        } else {
          helper.addAnneeScolaire(annee, operation: SyncOperation.insert);
        }
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte ann√©es scolaires: $e');
    }

    // Collecter les responsables non synchronis√©s
    try {
      final unsyncedResponsables = await database.responsableDao
          .getUnsyncedResponsables();
      print(
        'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ [SYNC] ${unsyncedResponsables.length} responsables non synchronis√©s trouv√©s',
      );
      for (final responsable in unsyncedResponsables) {
        helper.addEntity(
          responsable,
          'responsables',
          responsable.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (r) => r.toJson(),
          getServerId: (r) => r.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte responsables: $e');
    }

    // Collecter les cours non synchronis√©s
    try {
      final unsyncedCours = await database.coursDao.getUnsyncedCours();
      print('üìñ [SYNC] ${unsyncedCours.length} cours non synchronis√©s trouv√©s');
      for (final cours in unsyncedCours) {
        helper.addEntity(
          cours,
          'cours',
          cours.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (c) => c.toJson(),
          getServerId: (c) => c.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte cours: $e');
    }

    // Collecter les frais scolaires non synchronis√©s
    try {
      final unsyncedFrais = await database.fraisScolaireDao
          .getUnsyncedFraisScolaires();
      print(
        'üìã [SYNC] ${unsyncedFrais.length} frais scolaires non synchronis√©s trouv√©s',
      );
      for (final frais in unsyncedFrais) {
        helper.addEntity(
          frais,
          'frais_scolaires',
          frais.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (f) => f.toJson(),
          getServerId: (f) => f.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte frais scolaires: $e');
    }

    // Collecter les frais classes non synchronis√©s
    try {
      final unsyncedFraisClasses = await database.fraisClassesDao
          .getUnsyncedFraisClasses();
      print(
        'üìã [SYNC] ${unsyncedFraisClasses.length} frais classes non synchronis√©s trouv√©s',
      );
      for (final fraisClasse in unsyncedFraisClasses) {
        helper.addEntity(
          fraisClasse,
          'frais_classes',
          fraisClasse.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (f) => f.toJson(),
          getServerId: (f) => f.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte frais classes: $e');
    }

    // Collecter les notes de p√©riode non synchronis√©es
    try {
      final unsyncedNotes = await database.notePeriodeDao
          .getUnsyncedNotesPeriode();
      print(
        'üìö [SYNC] ${unsyncedNotes.length} notes de p√©riode non synchronis√©es trouv√©es',
      );
      for (final note in unsyncedNotes) {
        helper.addEntity(
          note,
          'notes_periode',
          note.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (n) => n.toJson(),
          getServerId: (n) => n.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte notes p√©riode: $e');
    }

    // Collecter les paiements de frais non synchronis√©s
    try {
      final unsyncedPaiements = await database.paiementFraisDao
          .getUnsyncedPaiementsFrais();
      print(
        'üí∞ [SYNC] ${unsyncedPaiements.length} paiements de frais non synchronis√©s trouv√©s',
      );
      for (final paiement in unsyncedPaiements) {
        helper.addEntity(
          paiement,
          'paiement_frais',
          paiement.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (p) => p.toJson(),
          getServerId: (p) => p.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte paiements frais: $e');
    }

    // Collecter les p√©riodes non synchronis√©es
    try {
      final unsyncedPeriodes = await database.periodeDao.getUnsyncedPeriodes();
      print(
        '‚è∞ [SYNC] ${unsyncedPeriodes.length} p√©riodes non synchronis√©es trouv√©es',
      );
      for (final periode in unsyncedPeriodes) {
        helper.addEntity(
          periode,
          'periodes',
          periode.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (p) => p.toJson(),
          getServerId: (p) => p.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte p√©riodes: $e');
    }

    // Collecter les cr√©ances non synchronis√©es
    try {
      final unsyncedCreances = await database.creanceDao.getUnsyncedCreances();
      print(
        'üí≥ [SYNC] ${unsyncedCreances.length} cr√©ances non synchronis√©es trouv√©es',
      );
      for (final creance in unsyncedCreances) {
        helper.addEntity(
          creance,
          'creances',
          creance.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (c) => c.toJson(),
          getServerId: (c) => c.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte cr√©ances: $e');
    }

    // Collecter les utilisateurs non synchronis√©s
    try {
      final unsyncedUtilisateurs = await database.utilisateurDao
          .getUnsyncedUtilisateurs();
      print(
        'üë§ [SYNC] ${unsyncedUtilisateurs.length} utilisateurs non synchronis√©s trouv√©s',
      );
      for (final utilisateur in unsyncedUtilisateurs) {
        helper.addEntity(
          utilisateur,
          'utilisateurs',
          utilisateur.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (u) => u.toJson(),
          getServerId: (u) => u.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte utilisateurs: $e');
    }

    // Collecter les configurations d'√©cole non synchronis√©es
    try {
      final unsyncedConfigs = await database.configEcoleDao
          .getUnsyncedConfigsEcole();
      print(
        '‚öôÔ∏è [SYNC] ${unsyncedConfigs.length} configurations d\'√©cole non synchronis√©es trouv√©es',
      );
      for (final config in unsyncedConfigs) {
        helper.addEntity(
          config,
          'configs_ecole',
          config.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (c) => c.toJson(),
          getServerId: (c) => c.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte configs √©cole: $e');
    }

    // Collecter les p√©riodes-classes non synchronis√©es
    try {
      final unsyncedPeriodesClasses = await database.periodesClassesDao
          .getUnsyncedPeriodesClasses();
      print(
        'üìö [SYNC] ${unsyncedPeriodesClasses.length} p√©riodes-classes non synchronis√©es trouv√©es',
      );
      for (final pc in unsyncedPeriodesClasses) {
        helper.addEntity(
          pc,
          'periodes_classes',
          pc.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (pc) => pc.toJson(),
          getServerId: (pc) => pc.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte p√©riodes-classes: $e');
    }

    // Tables comptables
    // Collecter les comptes comptables non synchronis√©s
    try {
      final unsyncedComptes = await database.compteComptableDao
          .getUnsyncedComptesComptables();
      print(
        'üíº [SYNC] ${unsyncedComptes.length} comptes comptables non synchronis√©s trouv√©s',
      );
      for (final compte in unsyncedComptes) {
        helper.addEntity(
          compte,
          'comptes_comptables',
          compte.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (c) => c.toJson(),
          getServerId: (c) => c.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte comptes comptables: $e');
    }

    // Collecter les classes comptables non synchronis√©es
    try {
      final unsyncedClassesComptables = await database.classeComptableDao
          .getUnsyncedClassesComptables();
      print(
        'üìä [SYNC] ${unsyncedClassesComptables.length} classes comptables non synchronis√©es trouv√©es',
      );
      for (final classe in unsyncedClassesComptables) {
        helper.addEntity(
          classe,
          'classes_comptables',
          classe.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (c) => c.toJson(),
          getServerId: (c) => c.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte classes comptables: $e');
    }

    // Collecter les journaux comptables non synchronis√©s
    try {
      final unsyncedJournaux = await database.journalComptableDao
          .getUnsyncedJournauxComptables();
      print(
        'üìì [SYNC] ${unsyncedJournaux.length} journaux comptables non synchronis√©s trouv√©s',
      );
      for (final journal in unsyncedJournaux) {
        helper.addEntity(
          journal,
          'journaux_comptables',
          journal.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (j) => j.toJson(),
          getServerId: (j) => j.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte journaux comptables: $e');
    }

    // Collecter les √©critures comptables non synchronis√©es
    try {
      final unsyncedEcritures = await database.ecritureComptableDao
          .getUnsyncedEcrituresComptables();
      print(
        'üìù [SYNC] ${unsyncedEcritures.length} √©critures comptables non synchronis√©es trouv√©es',
      );
      for (final ecriture in unsyncedEcritures) {
        helper.addEntity(
          ecriture,
          'ecritures_comptables',
          ecriture.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (e) => e.toJson(),
          getServerId: (e) => e.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte √©critures comptables: $e');
    }

    // Collecter les d√©penses non synchronis√©es
    try {
      final unsyncedDepenses = await database.depenseDao.getUnsyncedDepenses();
      print(
        'üí∏ [SYNC] ${unsyncedDepenses.length} d√©penses non synchronis√©es trouv√©es',
      );
      for (final depense in unsyncedDepenses) {
        helper.addEntity(
          depense,
          'depenses',
          depense.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (d) => d.toJson(),
          getServerId: (d) => d.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte d√©penses: $e');
    }

    // Collecter les licences non synchronis√©es
    try {
      final unsyncedLicences = await database.licenceDao.getUnsyncedLicences();
      print(
        'üìú [SYNC] ${unsyncedLicences.length} licences non synchronis√©es trouv√©es',
      );
      for (final licence in unsyncedLicences) {
        helper.addEntity(
          licence,
          'licences',
          licence.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (l) => l.toJson(),
          getServerId: (l) => l.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte licences: $e');
    }

    // Collecter les entreprises non synchronis√©es
    try {
      final unsyncedEntreprises = await database.entrepriseDao
          .getUnsyncedEntreprises();
      print(
        'üè¢ [SYNC] ${unsyncedEntreprises.length} entreprises non synchronis√©es trouv√©es',
      );
      for (final entreprise in unsyncedEntreprises) {
        helper.addEntity(
          entreprise,
          'entreprises',
          entreprise.serverId != null
              ? SyncOperation.update
              : SyncOperation.insert,
          toJson: (e) => e.toJson(),
          getServerId: (e) => e.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte entreprises: $e');
    }

    // Collecter les configurations de comptes non synchronis√©es
    try {
      final unsyncedComptesConfigs = await database.comptesConfigDao
          .getUnsyncedComptesConfigs();
      print(
        'üîß [SYNC] ${unsyncedComptesConfigs.length} configurations de comptes non synchronis√©es trouv√©es',
      );
      for (final config in unsyncedComptesConfigs) {
        helper.addEntity(
          config,
          'comptes_configs',
          config.serverId != null ? SyncOperation.update : SyncOperation.insert,
          toJson: (c) => c.toJson(),
          getServerId: (c) => c.serverId,
        );
      }
    } catch (e) {
      print('‚ùå [SYNC] Erreur collecte configurations comptes: $e');
    }

    print('‚úÖ [SYNC] Collecte des changements termin√©e');
  }

  /// Marque les changements comme synchronis√©s apr√®s upload r√©ussi
  Future<void> _markChangesAsSynced(SyncUploadHelper helper) async {
    print('‚úÖ [SYNC] D√©marrage marquage changements synchronis√©s');
    final database = ref.read(databaseProvider);
    final changesByTable = helper.changesByTable;

    // Marquer les √©l√®ves comme synchronis√©s
    if (changesByTable.containsKey('eleves')) {
      try {
        final eleveChanges = changesByTable['eleves']!;
        print(
          'üë®‚Äçüéì [SYNC] Marquage ${eleveChanges.length} √©l√®ves comme synchronis√©s',
        );
        for (final change in eleveChanges) {
          final eleveId = change.data['id'] as int?;
          if (eleveId != null) {
            await database.eleveDao.markAsSynced(eleveId);
          }
        }
      } catch (e) {
        print('‚ùå [SYNC] Erreur marquage √©l√®ves: $e');
      }
    }

    // Marquer les enseignants comme synchronis√©s
    if (changesByTable.containsKey('enseignants')) {
      try {
        final enseignantChanges = changesByTable['enseignants']!;
        print(
          'üë®‚Äçüè´ [SYNC] Marquage ${enseignantChanges.length} enseignants comme synchronis√©s',
        );
        for (final change in enseignantChanges) {
          final enseignantId = change.data['id'] as int?;
          if (enseignantId != null) {
            await database.enseignantDao.markAsSynced(enseignantId);
          }
        }
      } catch (e) {
        print('‚ùå [SYNC] Erreur marquage enseignants: $e');
      }
    }

    // Marquer les paiements de frais comme synchronis√©s
    if (changesByTable.containsKey('paiement_frais')) {
      try {
        final paiementChanges = changesByTable['paiement_frais']!;
        print(
          'üí≥ [SYNC] Marquage ${paiementChanges.length} paiements comme synchronis√©s',
        );
        for (final change in paiementChanges) {
          final paiementId = change.data['id'] as int?;
          if (paiementId != null) {
            await database.paiementFraisDao.markAsSynced(paiementId);
          }
        }
      } catch (e) {
        print('‚ùå [SYNC] Erreur marquage paiements: $e');
      }
    }

    // Marquer les responsables comme synchronis√©s
    if (changesByTable.containsKey('responsables')) {
      try {
        final responsableChanges = changesByTable['responsables']!;
        print(
          'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ [SYNC] Marquage ${responsableChanges.length} responsables comme synchronis√©s',
        );
        for (final change in responsableChanges) {
          final responsableId = change.data['id'] as int?;
          if (responsableId != null) {
            await database.responsableDao.markAsSynced(responsableId);
          }
        }
      } catch (e) {
        print('‚ùå [SYNC] Erreur marquage responsables: $e');
      }
    }

    // Marquer les d√©penses comme synchronis√©es
    if (changesByTable.containsKey('depenses')) {
      try {
        final depenseChanges = changesByTable['depenses']!;
        print(
          'üí∞ [SYNC] Marquage ${depenseChanges.length} d√©penses comme synchronis√©es',
        );
        for (final change in depenseChanges) {
          final depenseId = change.data['id'] as int?;
          if (depenseId != null) {
            await database.depenseDao.markAsSynced(depenseId);
          }
        }
      } catch (e) {
        print('‚ùå [SYNC] Erreur marquage d√©penses: $e');
      }
    }

    // Marquer les cr√©ances comme synchronis√©es
    if (changesByTable.containsKey('creances')) {
      try {
        final creanceChanges = changesByTable['creances']!;
        print(
          'üìã [SYNC] Marquage ${creanceChanges.length} cr√©ances comme synchronis√©es',
        );
        for (final change in creanceChanges) {
          final creanceId = change.data['id'] as int?;
          if (creanceId != null) {
            await database.creanceDao.markAsSynced(creanceId);
          }
        }
      } catch (e) {
        print('‚ùå [SYNC] Erreur marquage cr√©ances: $e');
      }
    }

    print('‚úÖ [SYNC] Marquage synchronisation termin√©');
  }

  /// Synchronisation bidirectionnelle compl√®te
  Future<void> performBidirectionalSync(String userEmail) async {
    print(
      'üîÑ [SYNC] D√©marrage synchronisation bidirectionnelle pour $userEmail',
    );
    try {
      // 1. Upload des changements locaux d'abord
      print('üì§ [SYNC] √âtape 1: Upload des changements locaux');
      await uploadLocalChanges(userEmail);

      // 2. Download des changements du serveur
      print('üì• [SYNC] √âtape 2: Download des changements serveur');
      await performFullSync(userEmail);

      print('‚úÖ [SYNC] Synchronisation bidirectionnelle termin√©e');
    } catch (e) {
      print('‚ùå [SYNC] Erreur synchronisation bidirectionnelle: $e');
      state = state.copyWith(
        status: SyncStatus.error,
        error: 'Erreur sync bidirectionnelle: $e',
      );
      rethrow;
    }
  }

  /// Force une synchronisation (ignore la derni√®re date)
  Future<void> performForcedSync(String userEmail) async {
    print('üîÑ [SYNC] D√©marrage synchronisation forc√©e pour $userEmail');
    final syncPrefs = ref.read(syncPreferencesNotifierProvider.notifier);
    print('üóëÔ∏è [SYNC] R√©initialisation des donn√©es de synchronisation');
    await syncPrefs.clearSyncData();
    await performFullSync(userEmail);
    print('‚úÖ [SYNC] Synchronisation forc√©e termin√©e');
  }

  /// Remet √† z√©ro l'√©tat de synchronisation
  void resetState() {
    print('üîÑ [SYNC] R√©initialisation de l\'√©tat de synchronisation');
    state = const SyncState();
  }
}
